引用类型(reference type)存储的是对象的内存地址。C++中有两种引用类型：指针、引用

# 指针

可以通过在目标类型上添加星号(`*`)来声明指针的类型。

指针的格式指定符是`%p`。

**解引用**：根据给定的指针获得在相应地址的对象本身。

## 取变量地址

可以通过在变量前面加上地址运算符(&)来获得变量的地址。可以用来对指针进行初始化操作。

## 指针解引用

解引用运算符(`*`)是一个一元运算符，它可以访问指针所指的对象。这是地址运算符的逆运算。

## 成员指针运算符

成员指针运算符或箭头运算符(`->`)同时执行两个操作：

❑ 它对指针解引用。

❑ 它访问被指向的对象的成员。

## 指针和数组

指针对对象的位置进行编码，而数组则对连续对象的位置和长度进行编码。

只要稍微对数组施加操作，数组就会退化成指针。退化后的数组会失去长度信息，并转换为指向数组第一个元素的指针。

**处理退化问题**：传递数组到指针时，带上数组长度。方括号对指针的作用就像对数组的作用一样。

**指针算术**：在指针上进行加减法的一套规则，则提供了另一种方法。

当在指针上加减整数时，编译器会使用指针指向的类型的大小计算出正确的字节偏移。

## 指针很危险

**缓冲区溢出**：C++不会在编译阶段对数组进行边界线检查。

**括号和指针算术之间的联系**：括号像是指针算数与解引用的更具可读性的写法。使用括号编译阶段会给出**warning**，而使用指针算术**不会**。

## void指针和std::byte指针

**void指针**有严格的限制，其中最主要的限制是不能对`void*`进行解引用。C++禁止使用void指针算术。

**在字节级别与内存进行交互**：

在文件和内存之间复制原始数据或者加密和压缩等底层操作。不能使用void指针来实现这样的目的，因为位操作和指针算术是被禁止的。在这种情况下，可以使用`std::byte`指针。

## nullptr和布尔表达式

一般来说，等于`nullptr`的指针不指向任何东西。

指针具有隐式转换为布尔值的功能。任何不是`nullptr`的值都会隐式转换为**true**，而`nullptr`则会隐式转换为**false**。

# 引用

引用(reference)是指针的更安全、更方便版本。

在类型名后附加`&`声明符即可声明引用。引用**不能被（轻易）设置为空**，也**不能被重新定位（或重新赋值）**。

有了引用就不需要麻烦的使用**解引用**和**指针运算符**了。

# 指针和引用的使用

指针和引用在很大程度上是可以互换的，但两者各有利弊。

如果有时**必须改变引用类型的值**，也就是说如果必须改变引用类型所指向的内容，那么必须使用指针。许多数据结构都要求能够改变指针的值。例如**前向链表**。

如果**不需要灵活地重新定位和nullptr**，引用是最常用的引用类型。

## this指针

需要访问当前对象，可以使用this指针。

通常情况下，访问成员时，**this是隐式**的。有时，**需要用this来消除成员和参数之间的歧义**。

## const正确性

它是一种安全机制，可以防止成员变量被意外修改（以及带来潜在的破坏）。

可以在函数和类的定义中使用`const`来指定变量（通常是引用或指针），表示该变量不会被该函数或类修改。

## const参数

将参数标记为`const`可以防止在函数的作用域内修改它。

## const方法

将方法标记为`const`表示承诺**不会**在`const`方法中**修改当前对象的状态**。换句话说，这些方法都是只读方法。

要将方法标记为const，需要将const关键字**放在参数列表之后**，但在**方法体之前**。

**const引用和指针的持有者不能调用非const方法**，因为非const方法可能会修改对象的状态。

## const成员变量

**在成员的类型前**添加关键字const即可标记const成员变量。const成员变量在初始化后不能被修改。

## 成员初始化列表

成员初始化列表是初始化类成员的主要机制。

要声明成员初始化列表，请在构造函数中的参数列表后放置一个冒号，然后插入一个或多个逗号分隔的成员初始化器。

成员初始化器指成员名称后面跟着大括号的初始化过程。成员初始化器允许在运行时设置const字段的值。

所有的成员初始化都在构造函数之前执行。这有两个好处：

❑ 它在构造函数执行之前确保所有成员的有效性，所以可以让我们专注于初始化逻辑而不是成员错误检查。

❑ 成员只初始化一次。如果在构造函数中重新给成员赋值，可能会产生额外的工作量

# auto类型推断

当初始化元素或返回函数返回值时，编译器可以根据上下文推断出类型信息。`auto`关键字告诉编译器执行这样的推断，这样我们就不用输入多余的类型信息了。

处理来自标准库容器的迭代器时——它确实可以节省不少输入操作。它还能让代码在重构时更灵活。

## auto和引用类型

可以在auto前后添加修饰符，如`&`、`*`和`const`。这种修饰会增加特定的含义（分别是引用、指针和const）。

## auto和代码重构

auto关键字有助于使代码更简单，在重构时更灵活。

一般而言，建议总是使用auto。